export interface Highlight {
  elements: HTMLElement[]
  annotationId: string
}

function isNodeInRange(range: Range, node: Node): boolean {
  try {
    const nodeRange = node.ownerDocument!.createRange()
    nodeRange.selectNodeContents(node)
    return (
      range.compareBoundaryPoints(Range.END_TO_START, nodeRange) <= 0
      && range.compareBoundaryPoints(Range.START_TO_END, nodeRange) >= 0
    )
  }
  catch {
    return false
  }
}

/**
 * Get all Text nodes within a range, splitting text nodes at range boundaries.
 *
 * @param range - Range to extract text nodes from
 * @return Array of Text nodes wholly contained in the range
 */
function wholeTextNodesInRange(range: Range): Text[] {
  if (range.collapsed) {
    // Exit early for an empty range to avoid an edge case that breaks the algorithm
    // below. Splitting a text node at the start of an empty range can leave the
    // range ending in the left part rather than the right part.
    return []
  }

  let root = range.commonAncestorContainer as Node | null
  if (root && root.nodeType !== Node.ELEMENT_NODE) {
    // If the common ancestor is not an element, set it to the parent element to
    // ensure that the loop below visits any text nodes generated by splitting
    // the common ancestor.
    //
    // Note that `parentElement` may be `null`.
    root = root.parentElement
  }
  if (!root) {
    // If there is no root element then we won't be able to insert highlights,
    // so exit here.
    return []
  }

  const textNodes: Text[] = []
  const nodeIter = root.ownerDocument!.createNodeIterator(
    root,
    NodeFilter.SHOW_TEXT, // Only return `Text` nodes.
  )

  let node: Node | null
  while ((node = nodeIter.nextNode())) {
    if (!isNodeInRange(range, node)) {
      continue
    }

    const text = node as Text

    if (text === range.startContainer && range.startOffset > 0) {
      // Split `text` where the range starts. The split will create a new `Text`
      // node which will be in the range and will be visited in the next loop iteration.
      text.splitText(range.startOffset)
      continue
    }

    if (text === range.endContainer && range.endOffset < text.data.length) {
      // Split `text` where the range ends, leaving it as the part in the range.
      text.splitText(range.endOffset)
    }

    textNodes.push(text)
  }

  return textNodes
}

/**
 * Wraps the DOM Nodes within the provided range with a highlight element
 * and returns the highlight Elements.
 *
 * @param range - Range to be highlighted
 * @param annotationId - ID of the annotation
 * @return Elements wrapping text in range to add a highlight effect
 */
export function highlightRange(range: Range, annotationId: string): Highlight {
  const textNodes = wholeTextNodesInRange(range)
  const elements: HTMLElement[] = []

  // Group text nodes into spans of adjacent nodes. If a group of text nodes are
  // adjacent, we only need to create one highlight element for the group.
  let textNodeSpans: Text[][] = []
  let prevNode: Node | null = null
  let currentSpan: Text[] | null = null

  textNodes.forEach((node) => {
    if (prevNode && prevNode.nextSibling === node) {
      currentSpan!.push(node)
    }
    else {
      currentSpan = [node]
      textNodeSpans.push(currentSpan)
    }
    prevNode = node
  })

  // Filter out text node spans that consist only of white space. This avoids
  // inserting highlight elements in places that can only contain a restricted
  // subset of nodes such as table rows and lists.
  const whitespace = /^\s*$/
  textNodeSpans = textNodeSpans.filter((span) => {
    const parentElement = span[0].parentElement
    return (
      // Whitespace <span> should be highlighted since they affect layout in
      // some code editors
      (parentElement?.childNodes.length === 1
        && parentElement?.tagName === 'SPAN')
      // Otherwise ignore white-space only Text node spans
      || span.some(node => !whitespace.test(node.data))
    )
  })

  // Wrap each text node span with a `<rda-highlight>` element.
  textNodeSpans.forEach((nodes) => {
    const highlight = document.createElement('rda-highlight')
    highlight.className = 'rda-highlight'
    highlight.setAttribute('data-annotation-id', annotationId)

    const parent = nodes[0].parentNode
    if (parent) {
      parent.replaceChild(highlight, nodes[0])
      nodes.forEach(node => highlight.appendChild(node))
      elements.push(highlight)
    }
  })

  return { elements, annotationId }
}

export function removeHighlight(highlight: Highlight): void {
  for (const element of highlight.elements) {
    const parent = element.parentNode
    if (parent) {
      while (element.firstChild) {
        parent.insertBefore(element.firstChild, element)
      }
      parent.removeChild(element)
      // Note: normalize() is NOT called here to avoid issues when removing
      // multiple highlights. Normalization should be done in batch after all
      // highlights are removed. See annotation-manager.ts clearAnnotations()
    }
  }
}

export function setHighlightFocused(
  highlight: Highlight,
  focused: boolean,
): void {
  for (const element of highlight.elements) {
    if (focused) {
      element.classList.add('rda-highlight-focused')
    }
    else {
      element.classList.remove('rda-highlight-focused')
    }
  }
}
